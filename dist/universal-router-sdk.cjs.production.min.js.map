{"version":3,"file":"universal-router-sdk.cjs.production.min.js","sources":["../src/entities/Command.ts","../src/entities/NFTTrade.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/numbers.ts","../src/utils/inputTokens.ts","../src/swapRouter.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRareV2.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts","../src/utils/routerTradeAdapter.ts","../src/entities/protocols/unwrapWETH.ts"],"sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\r\n\r\nexport type TradeConfig = {\r\n  allowRevert: boolean\r\n}\r\n\r\nexport enum RouterTradeType {\r\n  UniswapTrade = 'UniswapTrade',\r\n  NFTTrade = 'NFTTrade',\r\n  UnwrapWETH = 'UnwrapWETH',\r\n}\r\n\r\n// interface for entities that can be encoded as a Universal Router command\r\nexport interface Command {\r\n  tradeType: RouterTradeType\r\n  encode(planner: RoutePlanner, config: TradeConfig): void\r\n}\r\n","import invariant from 'tiny-invariant'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\nimport { SeaportData } from './protocols/seaport'\r\nimport { FoundationData } from './protocols/foundation'\r\nimport { NFTXData } from './protocols/nftx'\r\nimport { NFT20Data } from './protocols/nft20'\r\nimport { RoutePlanner } from '../utils/routerCommands'\r\nimport { Command, RouterTradeType, TradeConfig } from './Command'\r\nimport { SudoswapData } from './protocols/sudoswap'\r\nimport { CryptopunkData } from './protocols/cryptopunk'\r\nimport { X2Y2Data } from './protocols/x2y2'\r\nimport { ElementData } from './protocols/element-market'\r\nimport { LooksRareV2Data } from './protocols/looksRareV2'\r\n\r\nexport type SupportedProtocolsData =\r\n  | SeaportData\r\n  | FoundationData\r\n  | NFTXData\r\n  | LooksRareV2Data\r\n  | X2Y2Data\r\n  | CryptopunkData\r\n  | NFT20Data\r\n  | SudoswapData\r\n  | ElementData\r\n\r\nexport abstract class NFTTrade<T> implements Command {\r\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\r\n  readonly orders: T[]\r\n  readonly market: Market\r\n\r\n  constructor(market: Market, orders: T[]) {\r\n    invariant(orders.length > 0, 'no buy Items')\r\n    this.market = market\r\n    this.orders = orders\r\n  }\r\n\r\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\r\n\r\n  abstract getBuyItems(): BuyItem[]\r\n\r\n  // optional parameter for the markets that accept ERC20s not just ETH\r\n  abstract getTotalPrice(token?: string): BigNumber\r\n}\r\n\r\nexport type BuyItem = {\r\n  tokenAddress: string\r\n  tokenId: BigNumberish\r\n  tokenType: TokenType\r\n  amount?: BigNumberish // for 1155\r\n}\r\n\r\nexport enum Market {\r\n  Foundation = 'foundation',\r\n  LooksRareV2 = 'looksrareV2',\r\n  NFT20 = 'nft20',\r\n  NFTX = 'nftx',\r\n  Seaport = 'seaport',\r\n  Sudoswap = 'Sudoswap',\r\n  Cryptopunks = 'cryptopunks',\r\n  X2Y2 = 'x2y2',\r\n  Element = 'element',\r\n}\r\n\r\nexport enum TokenType {\r\n  ERC721 = 'ERC721',\r\n  ERC1155 = 'ERC1155',\r\n  Cryptopunk = 'Cryptopunk',\r\n}\r\n","import { defaultAbiCoder } from 'ethers/lib/utils'\r\n\r\n/**\r\n * CommandTypes\r\n * @description Flags that modify a command's execution\r\n * @enum {number}\r\n */\r\nexport enum CommandType {\r\n  V3_SWAP_EXACT_IN = 0x00,\r\n  V3_SWAP_EXACT_OUT = 0x01,\r\n  PERMIT2_TRANSFER_FROM = 0x02,\r\n  PERMIT2_PERMIT_BATCH = 0x03,\r\n  SWEEP = 0x04,\r\n  TRANSFER = 0x05,\r\n  PAY_PORTION = 0x06,\r\n\r\n  V2_SWAP_EXACT_IN = 0x08,\r\n  V2_SWAP_EXACT_OUT = 0x09,\r\n  PERMIT2_PERMIT = 0x0a,\r\n  WRAP_ETH = 0x0b,\r\n  UNWRAP_WETH = 0x0c,\r\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\r\n  BALANCE_CHECK_ERC20 = 0x0e,\r\n\r\n  // NFT-related command types\r\n  SEAPORT_V1_5 = 0x10,\r\n  LOOKS_RARE_V2 = 0x11,\r\n  NFTX = 0x12,\r\n  CRYPTOPUNKS = 0x13,\r\n  // 0x14\r\n  OWNER_CHECK_721 = 0x15,\r\n  OWNER_CHECK_1155 = 0x16,\r\n  SWEEP_ERC721 = 0x17,\r\n\r\n  X2Y2_721 = 0x18,\r\n  SUDOSWAP = 0x19,\r\n  NFT20 = 0x1a,\r\n  X2Y2_1155 = 0x1b,\r\n  FOUNDATION = 0x1c,\r\n  SWEEP_ERC1155 = 0x1d,\r\n  ELEMENT_MARKET = 0x1e,\r\n\r\n  SEAPORT_V1_4 = 0x20,\r\n  EXECUTE_SUB_PLAN = 0x21,\r\n  APPROVE_ERC20 = 0x22,\r\n}\r\n\r\nconst ALLOW_REVERT_FLAG = 0x80\r\n\r\nconst REVERTIBLE_COMMANDS = new Set<CommandType>([\r\n  CommandType.SEAPORT_V1_5,\r\n  CommandType.SEAPORT_V1_4,\r\n  CommandType.NFTX,\r\n  CommandType.LOOKS_RARE_V2,\r\n  CommandType.X2Y2_721,\r\n  CommandType.X2Y2_1155,\r\n  CommandType.FOUNDATION,\r\n  CommandType.SUDOSWAP,\r\n  CommandType.NFT20,\r\n  CommandType.EXECUTE_SUB_PLAN,\r\n  CommandType.CRYPTOPUNKS,\r\n  CommandType.ELEMENT_MARKET,\r\n])\r\n\r\nconst PERMIT_STRUCT =\r\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details,address spender,uint256 sigDeadline)'\r\n\r\nconst PERMIT_BATCH_STRUCT =\r\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details,address spender,uint256 sigDeadline)'\r\n\r\nconst PERMIT2_TRANSFER_FROM_STRUCT = '(address from,address to,uint160 amount,address token)'\r\nconst PERMIT2_TRANSFER_FROM_BATCH_STRUCT = PERMIT2_TRANSFER_FROM_STRUCT + '[]'\r\n\r\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\r\n  // Batch Reverts\r\n  [CommandType.EXECUTE_SUB_PLAN]: ['bytes', 'bytes[]'],\r\n\r\n  // Permit2 Actions\r\n  [CommandType.PERMIT2_PERMIT]: [PERMIT_STRUCT, 'bytes'],\r\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\r\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\r\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: [PERMIT2_TRANSFER_FROM_BATCH_STRUCT],\r\n\r\n  // Uniswap Actions\r\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\r\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\r\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\r\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\r\n\r\n  // Token Actions and Checks\r\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\r\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\r\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\r\n  [CommandType.SWEEP_ERC721]: ['address', 'address', 'uint256'],\r\n  [CommandType.SWEEP_ERC1155]: ['address', 'address', 'uint256', 'uint256'],\r\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\r\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\r\n  [CommandType.BALANCE_CHECK_ERC20]: ['address', 'address', 'uint256'],\r\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\r\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\r\n  [CommandType.APPROVE_ERC20]: ['address', 'uint256'],\r\n\r\n  // NFT Markets\r\n  [CommandType.SEAPORT_V1_5]: ['uint256', 'bytes'],\r\n  [CommandType.SEAPORT_V1_4]: ['uint256', 'bytes'],\r\n  [CommandType.NFTX]: ['uint256', 'bytes'],\r\n  [CommandType.LOOKS_RARE_V2]: ['uint256', 'bytes'],\r\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\r\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\r\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\r\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\r\n  [CommandType.NFT20]: ['uint256', 'bytes'],\r\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\r\n  [CommandType.ELEMENT_MARKET]: ['uint256', 'bytes'],\r\n}\r\n\r\nexport class RoutePlanner {\r\n  commands: string\r\n  inputs: string[]\r\n\r\n  constructor() {\r\n    this.commands = '0x'\r\n    this.inputs = []\r\n  }\r\n\r\n  addSubPlan(subplan: RoutePlanner): void {\r\n    this.addCommand(CommandType.EXECUTE_SUB_PLAN, [subplan.commands, subplan.inputs], true)\r\n  }\r\n\r\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\r\n    let command = createCommand(type, parameters)\r\n    this.inputs.push(command.encodedInput)\r\n    if (allowRevert) {\r\n      if (!REVERTIBLE_COMMANDS.has(command.type)) {\r\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\r\n      }\r\n      command.type = command.type | ALLOW_REVERT_FLAG\r\n    }\r\n\r\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\r\n  }\r\n}\r\n\r\nexport type RouterCommand = {\r\n  type: CommandType\r\n  encodedInput: string\r\n}\r\n\r\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\r\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\r\n  return { type, encodedInput }\r\n}\r\n","import { BigNumber } from 'ethers'\r\n\r\ntype ChainConfig = {\r\n  router: string\r\n  creationBlock: number\r\n  weth: string\r\n}\r\n\r\nconst WETH_NOT_SUPPORTED_ON_CHAIN = '0x0000000000000000000000000000000000000000'\r\n\r\nconst CHAIN_CONFIGS: { [key: number]: ChainConfig } = {\r\n  // mainnet\r\n  [1]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\r\n    creationBlock: 17143817,\r\n  },\r\n  // goerli\r\n  [5]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6',\r\n    creationBlock: 8940568,\r\n  },\r\n  // sepolia\r\n  [11155111]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14',\r\n    creationBlock: 3543575,\r\n  },\r\n  // polygon\r\n  [137]: {\r\n    router: '0xec7BE89e9d109e7e3Fec59c222CF297125FEFda2',\r\n    weth: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',\r\n    creationBlock: 52210153,\r\n  },\r\n  //polygon mumbai\r\n  [80001]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889',\r\n    creationBlock: 35176052,\r\n  },\r\n  //optimism\r\n  [10]: {\r\n    router: '0xCb1355ff08Ab38bBCE60111F1bb2B784bE25D7e8',\r\n    weth: '0x4200000000000000000000000000000000000006',\r\n    creationBlock: 114702266,\r\n  },\r\n  // optimism goerli\r\n  [420]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0x4200000000000000000000000000000000000006',\r\n    creationBlock: 8887728,\r\n  },\r\n  // arbitrum\r\n  [42161]: {\r\n    router: '0x5E325eDA8064b456f4781070C0738d849c824258',\r\n    weth: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\r\n    creationBlock: 169472836,\r\n  },\r\n  // arbitrum goerli\r\n  [421613]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3',\r\n    creationBlock: 18815277,\r\n  },\r\n  // celo\r\n  [42220]: {\r\n    router: '0x643770e279d5d0733f21d6dc03a8efbabf3255b4',\r\n    weth: WETH_NOT_SUPPORTED_ON_CHAIN,\r\n    creationBlock: 21407637,\r\n  },\r\n  // celo alfajores\r\n  [44787]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: WETH_NOT_SUPPORTED_ON_CHAIN,\r\n    creationBlock: 17566658,\r\n  },\r\n  // binance smart chain\r\n  [56]: {\r\n    router: '0x4Dae2f939ACf50408e13d58534Ff8c2776d45265',\r\n    weth: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\r\n    creationBlock: 35160263,\r\n  },\r\n  // avalanche\r\n  [43114]: {\r\n    router: '0x4Dae2f939ACf50408e13d58534Ff8c2776d45265',\r\n    weth: '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7',\r\n    creationBlock: 40237257,\r\n  },\r\n  // base goerli\r\n  [84531]: {\r\n    router: '0xd0872d928672ae2ff74bdb2f5130ac12229cafaf',\r\n    weth: '0x4200000000000000000000000000000000000006',\r\n    creationBlock: 6915289,\r\n  },\r\n  // base mainnet\r\n  [8453]: {\r\n    router: '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',\r\n    weth: '0x4200000000000000000000000000000000000006',\r\n    creationBlock: 9107268,\r\n  },\r\n  [81457]: {\r\n    router: '0x643770E279d5D0733F21d6DC03A8efbABf3255B4',\r\n    weth: '0x4300000000000000000000000000000000000004',\r\n    creationBlock: 1116444,\r\n  },\r\n  [200810]:{\r\n    router: '0xc9022A5aB25719cbcaf87A61DAca6CE644BaFc40',\r\n    weth: '0x3e57d6946f893314324C975AA9CEBBdF3232967E',\r\n    creationBlock: 1116444,\r\n  }\r\n}\r\n\r\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\r\n  if (!(chainId in CHAIN_CONFIGS)) throw new Error(`Universal Router not deployed on chain ${chainId}`)\r\n  return CHAIN_CONFIGS[chainId].router\r\n}\r\n\r\nexport const UNIVERSAL_ROUTER_CREATION_BLOCK = (chainId: number): number => {\r\n  if (!(chainId in CHAIN_CONFIGS)) throw new Error(`Universal Router not deployed on chain ${chainId}`)\r\n  return CHAIN_CONFIGS[chainId].creationBlock\r\n}\r\n\r\nexport const WETH_ADDRESS = (chainId: number): string => {\r\n  if (!(chainId in CHAIN_CONFIGS)) throw new Error(`Universal Router not deployed on chain ${chainId}`)\r\n\r\n  if (CHAIN_CONFIGS[chainId].weth == WETH_NOT_SUPPORTED_ON_CHAIN) throw new Error(`Chain ${chainId} does not have WETH`)\r\n\r\n  return CHAIN_CONFIGS[chainId].weth\r\n}\r\n\r\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\r\n\r\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\r\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\r\nexport const E_ETH_ADDRESS = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'\r\nexport const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\r\nexport const MAX_UINT256 = BigNumber.from(2).pow(256).sub(1)\r\nexport const MAX_UINT160 = BigNumber.from(2).pow(160).sub(1)\r\n\r\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\r\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\r\n\r\nexport const OPENSEA_CONDUIT_SPENDER_ID = 0\r\nexport const SUDOSWAP_SPENDER_ID = 1\r\n","import { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { Trade as V2Trade, Pair } from '@uniswap/v2-sdk'\r\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@uniswap/v3-sdk'\r\nimport {\r\n  Trade as RouterTrade,\r\n  MixedRouteTrade,\r\n  Protocol,\r\n  IRoute,\r\n  RouteV2,\r\n  RouteV3,\r\n  MixedRouteSDK,\r\n  MixedRoute,\r\n  SwapOptions as RouterSwapOptions,\r\n  getOutputOfPools,\r\n  encodeMixedRouteToPath,\r\n  partitionMixedRouteByProtocol,\r\n} from '@uniswap/router-sdk'\r\nimport { Permit2Permit } from '../../utils/inputTokens'\r\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@uniswap/sdk-core'\r\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\r\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE, ETH_ADDRESS } from '../../utils/constants'\r\nimport { encodeFeeBips } from '../../utils/numbers'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\nexport type FlatFeeOptions = {\r\n  amount: BigNumberish\r\n  recipient: string\r\n}\r\n\r\n// the existing router permit object doesn't include enough data for permit2\r\n// so we extend swap options with the permit2 permit\r\n// when safe mode is enabled, the SDK will add an extra ETH sweep for security\r\n// when useRouterBalance is enabled the SDK will use the balance in the router for the swap\r\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\r\n  useRouterBalance?: boolean\r\n  inputTokenPermit?: Permit2Permit\r\n  flatFee?: FlatFeeOptions\r\n  safeMode?: boolean\r\n}\r\n\r\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(50, 100)\r\n\r\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\r\n  route: IRoute<TInput, TOutput, Pair | Pool>\r\n  inputAmount: CurrencyAmount<TInput>\r\n  outputAmount: CurrencyAmount<TOutput>\r\n}\r\n\r\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\r\n// also translates trade objects from previous (v2, v3) SDKs\r\nexport class UniswapTrade implements Command {\r\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\r\n  readonly payerIsUser: boolean\r\n\r\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {\r\n    if (!!options.fee && !!options.flatFee) throw new Error('Only one fee option permitted')\r\n\r\n    if (this.inputRequiresWrap) this.payerIsUser = false\r\n    else if (this.options.useRouterBalance) this.payerIsUser = false\r\n    else this.payerIsUser = true\r\n  }\r\n\r\n  get inputRequiresWrap(): boolean {\r\n    return this.trade.inputAmount.currency.isNative\r\n  }\r\n\r\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\r\n    // If the input currency is the native currency, we need to wrap it with the router as the recipient\r\n    if (this.inputRequiresWrap) {\r\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\r\n      planner.addCommand(CommandType.WRAP_ETH, [\r\n        ROUTER_AS_RECIPIENT,\r\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\r\n      ])\r\n    }\r\n    // The overall recipient at the end of the trade, SENDER_AS_RECIPIENT uses the msg.sender\r\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\r\n\r\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\r\n    //   1. when there are >2 exact input trades. this is only a heuristic,\r\n    //      as it's still more gas-expensive even in this case, but has benefits\r\n    //      in that the reversion probability is lower\r\n    const performAggregatedSlippageCheck =\r\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\r\n    const outputIsNative = this.trade.outputAmount.currency.isNative\r\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative || hasFeeOption(this.options)\r\n\r\n    for (const swap of this.trade.swaps) {\r\n      switch (swap.route.protocol) {\r\n        case Protocol.V2:\r\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, this.payerIsUser, routerMustCustody)\r\n          break\r\n        case Protocol.V3:\r\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, this.payerIsUser, routerMustCustody)\r\n          break\r\n        case Protocol.MIXED:\r\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, this.payerIsUser, routerMustCustody)\r\n          break\r\n        default:\r\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\r\n      }\r\n    }\r\n\r\n    let minimumAmountOut: BigNumber = BigNumber.from(\r\n      this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString()\r\n    )\r\n\r\n    // The router custodies for 3 reasons: to unwrap, to take a fee, and/or to do a slippage check\r\n    if (routerMustCustody) {\r\n      // If there is a fee, that percentage is sent to the fee recipient\r\n      // In the case where ETH is the output currency, the fee is taken in WETH (for gas reasons)\r\n      if (!!this.options.fee) {\r\n        const feeBips = encodeFeeBips(this.options.fee.fee)\r\n        planner.addCommand(CommandType.PAY_PORTION, [\r\n          this.trade.outputAmount.currency.wrapped.address,\r\n          this.options.fee.recipient,\r\n          feeBips,\r\n        ])\r\n\r\n        // If the trade is exact output, and a fee was taken, we must adjust the amount out to be the amount after the fee\r\n        // Otherwise we continue as expected with the trade's normal expected output\r\n        if (this.trade.tradeType === TradeType.EXACT_OUTPUT) {\r\n          minimumAmountOut = minimumAmountOut.sub(minimumAmountOut.mul(feeBips).div(10000))\r\n        }\r\n      }\r\n\r\n      // If there is a flat fee, that absolute amount is sent to the fee recipient\r\n      // In the case where ETH is the output currency, the fee is taken in WETH (for gas reasons)\r\n      if (!!this.options.flatFee) {\r\n        const feeAmount = this.options.flatFee.amount\r\n        if (minimumAmountOut.lt(feeAmount)) throw new Error('Flat fee amount greater than minimumAmountOut')\r\n\r\n        planner.addCommand(CommandType.TRANSFER, [\r\n          this.trade.outputAmount.currency.wrapped.address,\r\n          this.options.flatFee.recipient,\r\n          feeAmount,\r\n        ])\r\n\r\n        // If the trade is exact output, and a fee was taken, we must adjust the amount out to be the amount after the fee\r\n        // Otherwise we continue as expected with the trade's normal expected output\r\n        if (this.trade.tradeType === TradeType.EXACT_OUTPUT) {\r\n          minimumAmountOut = minimumAmountOut.sub(feeAmount)\r\n        }\r\n      }\r\n\r\n      // The remaining tokens that need to be sent to the user after the fee is taken will be caught\r\n      // by this if-else clause.\r\n      if (outputIsNative) {\r\n        planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, minimumAmountOut])\r\n      } else {\r\n        planner.addCommand(CommandType.SWEEP, [\r\n          this.trade.outputAmount.currency.wrapped.address,\r\n          this.options.recipient,\r\n          minimumAmountOut,\r\n        ])\r\n      }\r\n    }\r\n\r\n    if (this.inputRequiresWrap && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\r\n      // for exactOutput swaps that take native currency as input\r\n      // we need to send back the change to the user\r\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\r\n    }\r\n\r\n    if (this.options.safeMode) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, this.options.recipient, 0])\r\n  }\r\n}\r\n\r\n// encode a uniswap v2 swap\r\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\r\n  planner: RoutePlanner,\r\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\r\n  tradeType: TradeType,\r\n  options: SwapOptions,\r\n  payerIsUser: boolean,\r\n  routerMustCustody: boolean\r\n): void {\r\n  const trade = new V2Trade(\r\n    route as RouteV2<TInput, TOutput>,\r\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\r\n    tradeType\r\n  )\r\n\r\n  if (tradeType == TradeType.EXACT_INPUT) {\r\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\r\n      // if native, we have to unwrap so keep in the router for now\r\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\r\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\r\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\r\n      route.path.map((pool) => pool.address),\r\n      payerIsUser,\r\n    ])\r\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\r\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\r\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\r\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\r\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\r\n      route.path.map((pool) => pool.address),\r\n      payerIsUser,\r\n    ])\r\n  }\r\n}\r\n\r\n// encode a uniswap v3 swap\r\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\r\n  planner: RoutePlanner,\r\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\r\n  tradeType: TradeType,\r\n  options: SwapOptions,\r\n  payerIsUser: boolean,\r\n  routerMustCustody: boolean\r\n): void {\r\n  const trade = V3Trade.createUncheckedTrade({\r\n    route: route as RouteV3<TInput, TOutput>,\r\n    inputAmount,\r\n    outputAmount,\r\n    tradeType,\r\n  })\r\n\r\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\r\n  if (tradeType == TradeType.EXACT_INPUT) {\r\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\r\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\r\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\r\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\r\n      path,\r\n      payerIsUser,\r\n    ])\r\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\r\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\r\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\r\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\r\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\r\n      path,\r\n      payerIsUser,\r\n    ])\r\n  }\r\n}\r\n\r\n// encode a mixed route swap, i.e. including both v2 and v3 pools\r\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\r\n  planner: RoutePlanner,\r\n  swap: Swap<TInput, TOutput>,\r\n  tradeType: TradeType,\r\n  options: SwapOptions,\r\n  payerIsUser: boolean,\r\n  routerMustCustody: boolean\r\n): void {\r\n  const { route, inputAmount, outputAmount } = swap\r\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\r\n\r\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\r\n  if (route.pools.length === 1) {\r\n    if (route.pools[0] instanceof Pool) {\r\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\r\n    } else if (route.pools[0] instanceof Pair) {\r\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\r\n    } else {\r\n      throw new Error('Invalid route type')\r\n    }\r\n  }\r\n\r\n  const trade = MixedRouteTrade.createUncheckedTrade({\r\n    route: route as MixedRoute<TInput, TOutput>,\r\n    inputAmount,\r\n    outputAmount,\r\n    tradeType,\r\n  })\r\n\r\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\r\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\r\n\r\n  // logic from\r\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\r\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\r\n  const isLastSectionInRoute = (i: number) => {\r\n    return i === sections.length - 1\r\n  }\r\n\r\n  let outputToken\r\n  let inputToken = route.input.wrapped\r\n\r\n  for (let i = 0; i < sections.length; i++) {\r\n    const section = sections[i]\r\n    /// Now, we get output of this section\r\n    outputToken = getOutputOfPools(section, inputToken)\r\n\r\n    const newRouteOriginal = new MixedRouteSDK(\r\n      [...section],\r\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\r\n      outputToken\r\n    )\r\n    const newRoute = new MixedRoute(newRouteOriginal)\r\n\r\n    /// Previous output is now input\r\n    inputToken = outputToken\r\n\r\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\r\n      return route.pools.every((pool) => pool instanceof Pool)\r\n    }\r\n\r\n    if (mixedRouteIsAllV3(newRoute)) {\r\n      const path: string = encodeMixedRouteToPath(newRoute)\r\n\r\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\r\n        // if not last section: send tokens directly to the first v2 pair of the next section\r\n        // note: because of the partitioning function we can be sure that the next section is v2\r\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\r\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\r\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\r\n        path, // path\r\n        payerIsUser && i === 0, // payerIsUser\r\n      ])\r\n    } else {\r\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\r\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\r\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\r\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\r\n        newRoute.path.map((pool) => pool.address), // path\r\n        payerIsUser && i === 0,\r\n      ])\r\n    }\r\n  }\r\n}\r\n\r\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\r\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\r\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\r\n}\r\n\r\nfunction hasFeeOption(swapOptions: SwapOptions): boolean {\r\n  return !!swapOptions.fee || !!swapOptions.flatFee\r\n}\r\n","import { BigNumber } from 'ethers'\r\nimport JSBI from 'jsbi'\r\nimport bn from 'bignumber.js'\r\nimport { Percent } from '@uniswap/sdk-core'\r\nimport { toHex } from '@uniswap/v3-sdk'\r\n\r\nexport function expandTo18DecimalsBN(n: number): BigNumber {\r\n  // use bn intermediately to allow decimals in intermediate calculations\r\n  return BigNumber.from(new bn(n).times(new bn(10).pow(18)).toFixed())\r\n}\r\n\r\nexport function expandTo18Decimals(n: number): JSBI {\r\n  return JSBI.BigInt(BigNumber.from(n).mul(BigNumber.from(10).pow(18)).toString())\r\n}\r\n\r\nexport function encodeFeeBips(fee: Percent): string {\r\n  return toHex(fee.multiply(10_000).quotient)\r\n}\r\n","import invariant from 'tiny-invariant'\r\nimport { ethers } from 'ethers'\r\nimport { PermitSingle } from '@uniswap/permit2-sdk'\r\nimport { CommandType, RoutePlanner } from './routerCommands'\r\nimport { OPENSEA_CONDUIT_SPENDER_ID, ROUTER_AS_RECIPIENT, SUDOSWAP_SPENDER_ID } from './constants'\r\n\r\nexport interface Permit2Permit extends PermitSingle {\r\n  signature: string\r\n}\r\n\r\nexport type ApproveProtocol = {\r\n  token: string\r\n  protocol: string\r\n}\r\n\r\nexport type Permit2TransferFrom = {\r\n  token: string\r\n  amount: string\r\n  recipient?: string\r\n}\r\n\r\nexport type InputTokenOptions = {\r\n  approval?: ApproveProtocol\r\n  permit2Permit?: Permit2Permit\r\n  permit2TransferFrom?: Permit2TransferFrom\r\n}\r\n\r\nconst SIGNATURE_LENGTH = 65\r\nconst EIP_2098_SIGNATURE_LENGTH = 64\r\n\r\nexport function encodePermit(planner: RoutePlanner, permit2: Permit2Permit): void {\r\n  let signature = permit2.signature\r\n\r\n  const length = ethers.utils.arrayify(permit2.signature).length\r\n  // signature data provided for EIP-1271 may have length different from ECDSA signature\r\n  if (length === SIGNATURE_LENGTH || length === EIP_2098_SIGNATURE_LENGTH) {\r\n    // sanitizes signature to cover edge cases of malformed EIP-2098 sigs and v used as recovery id\r\n    signature = ethers.utils.joinSignature(ethers.utils.splitSignature(permit2.signature))\r\n  }\r\n\r\n  planner.addCommand(CommandType.PERMIT2_PERMIT, [permit2, signature])\r\n}\r\n\r\n// Handles the encoding of commands needed to gather input tokens for a trade\r\n// Approval: The router approving another address to take tokens.\r\n//   note: Only seaport and sudoswap support this action. Approvals are left open.\r\n// Permit: A Permit2 signature-based Permit to allow the router to access a user's tokens\r\n// Transfer: A Permit2 TransferFrom of tokens from a user to either the router or another address\r\nexport function encodeInputTokenOptions(planner: RoutePlanner, options: InputTokenOptions) {\r\n  // first ensure that all tokens provided for encoding are the same\r\n  if (!!options.approval && !!options.permit2Permit)\r\n    invariant(options.approval.token === options.permit2Permit.details.token, `inconsistent token`)\r\n  if (!!options.approval && !!options.permit2TransferFrom)\r\n    invariant(options.approval.token === options.permit2TransferFrom.token, `inconsistent token`)\r\n  if (!!options.permit2TransferFrom && !!options.permit2Permit)\r\n    invariant(options.permit2TransferFrom.token === options.permit2Permit.details.token, `inconsistent token`)\r\n\r\n  // if an options.approval is required, add it\r\n  if (!!options.approval) {\r\n    planner.addCommand(CommandType.APPROVE_ERC20, [\r\n      options.approval.token,\r\n      mapApprovalProtocol(options.approval.protocol),\r\n    ])\r\n  }\r\n\r\n  // if this order has a options.permit2Permit, encode it\r\n  if (!!options.permit2Permit) {\r\n    encodePermit(planner, options.permit2Permit)\r\n  }\r\n\r\n  if (!!options.permit2TransferFrom) {\r\n    planner.addCommand(CommandType.PERMIT2_TRANSFER_FROM, [\r\n      options.permit2TransferFrom.token,\r\n      options.permit2TransferFrom.recipient ? options.permit2TransferFrom.recipient : ROUTER_AS_RECIPIENT,\r\n      options.permit2TransferFrom.amount,\r\n    ])\r\n  }\r\n}\r\n\r\nfunction mapApprovalProtocol(protocolAddress: string): number {\r\n  switch (protocolAddress.toLowerCase()) {\r\n    case '0x00000000000000adc04c56bf30ac9d3c0aaf14dc': // Seaport v1.5\r\n      return OPENSEA_CONDUIT_SPENDER_ID\r\n    case '0x00000000000001ad428e4906ae43d8f9852d0dd6': // Seaport v1.4\r\n      return OPENSEA_CONDUIT_SPENDER_ID\r\n    case '0x2b2e8cda09bba9660dca5cb6233787738ad68329': // Sudoswap\r\n      return SUDOSWAP_SPENDER_ID\r\n    default:\r\n      throw new Error('unsupported protocol address')\r\n  }\r\n}\r\n","import invariant from 'tiny-invariant'\r\nimport { abi } from '@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\nimport { MethodParameters } from '@uniswap/v3-sdk'\r\nimport { Trade as RouterTrade } from '@uniswap/router-sdk'\r\nimport { Currency, TradeType } from '@uniswap/sdk-core'\r\nimport { Command, RouterTradeType } from './entities/Command'\r\nimport { Market, NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\r\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\r\nimport { UnwrapWETH } from './entities/protocols/unwrapWETH'\r\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\r\nimport { encodePermit } from './utils/inputTokens'\r\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\r\nimport { SeaportTrade } from './entities'\r\n\r\nexport type SwapRouterConfig = {\r\n  sender?: string // address\r\n  deadline?: BigNumberish\r\n}\r\n\r\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\r\n\r\nexport abstract class SwapRouter {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n\r\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\r\n    if (!Array.isArray(trades)) trades = [trades]\r\n\r\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\r\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\r\n    const planner = new RoutePlanner()\r\n\r\n    // track value flow to require the right amount of native value\r\n    let currentNativeValueInRouter = BigNumber.from(0)\r\n    let transactionValue = BigNumber.from(0)\r\n\r\n    // tracks the input tokens (and ETH) used to buy NFTs to allow us to sweep\r\n    let nftInputTokens = new Set<string>()\r\n\r\n    for (const trade of trades) {\r\n      /**\r\n       * is NFTTrade\r\n       */\r\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\r\n        const nftTrade = trade as SupportedNFTTrade\r\n        nftTrade.encode(planner, { allowRevert })\r\n        const tradePrice = nftTrade.getTotalPrice()\r\n\r\n        if (nftTrade.market == Market.Seaport) {\r\n          const seaportTrade = nftTrade as SeaportTrade\r\n          const seaportInputTokens = seaportTrade.getInputTokens()\r\n          seaportInputTokens.forEach((inputToken) => {\r\n            nftInputTokens.add(inputToken)\r\n          })\r\n        } else {\r\n          nftInputTokens.add(ETH_ADDRESS)\r\n        }\r\n\r\n        // send enough native value to contract for NFT purchase\r\n        if (currentNativeValueInRouter.lt(tradePrice)) {\r\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\r\n          currentNativeValueInRouter = BigNumber.from(0)\r\n        } else {\r\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\r\n        }\r\n        /**\r\n         * is UniswapTrade\r\n         */\r\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\r\n        const uniswapTrade = trade as UniswapTrade\r\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\r\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\r\n        const swapOptions = uniswapTrade.options\r\n\r\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\r\n\r\n        if (!!swapOptions.inputTokenPermit) {\r\n          encodePermit(planner, swapOptions.inputTokenPermit)\r\n        }\r\n\r\n        if (inputIsNative) {\r\n          transactionValue = transactionValue.add(\r\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\r\n          )\r\n        }\r\n        // track amount of native currency in the router\r\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\r\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\r\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\r\n          )\r\n        }\r\n        uniswapTrade.encode(planner, { allowRevert: false })\r\n        /**\r\n         * is UnwrapWETH\r\n         */\r\n      } else if (trade.tradeType == RouterTradeType.UnwrapWETH) {\r\n        const UnwrapWETH = trade as UnwrapWETH\r\n        trade.encode(planner, { allowRevert: false })\r\n        currentNativeValueInRouter = currentNativeValueInRouter.add(UnwrapWETH.amount)\r\n        /**\r\n         * else\r\n         */\r\n      } else {\r\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\r\n      }\r\n    }\r\n\r\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\r\n    // or NFT trades with potential slippage (i.e. sudo).\r\n    // Note: NFTXV2 sends excess ETH to the caller (router), not the specified recipient\r\n    nftInputTokens.forEach((inputToken) => {\r\n      planner.addCommand(CommandType.SWEEP, [inputToken, SENDER_AS_RECIPIENT, 0])\r\n    })\r\n    return SwapRouter.encodePlan(planner, transactionValue, config)\r\n  }\r\n\r\n  /**\r\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\r\n   * This version does not work correctly for Seaport ERC20->NFT purchases\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\r\n   * @param trades to produce call parameters for\r\n   */\r\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\r\n    let planner = new RoutePlanner()\r\n    let totalPrice = BigNumber.from(0)\r\n\r\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\r\n\r\n    for (const trade of trades) {\r\n      trade.encode(planner, { allowRevert })\r\n      totalPrice = totalPrice.add(trade.getTotalPrice())\r\n    }\r\n\r\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\r\n    return SwapRouter.encodePlan(planner, totalPrice, config)\r\n  }\r\n\r\n  /**\r\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trades to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\r\n  public static swapERC20CallParameters(\r\n    trades: RouterTrade<Currency, Currency, TradeType>,\r\n    options: SwapOptions\r\n  ): MethodParameters {\r\n    // TODO: use permit if signature included in swapOptions\r\n    const planner = new RoutePlanner()\r\n\r\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\r\n\r\n    const inputCurrency = trade.trade.inputAmount.currency\r\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\r\n\r\n    if (options.inputTokenPermit) {\r\n      encodePermit(planner, options.inputTokenPermit)\r\n    }\r\n\r\n    const nativeCurrencyValue = inputCurrency.isNative\r\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\r\n      : BigNumber.from(0)\r\n\r\n    trade.encode(planner, { allowRevert: false })\r\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\r\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Encodes a planned route into a method name and parameters for the Router contract.\r\n   * @param planner the planned route\r\n   * @param nativeCurrencyValue the native currency value of the planned route\r\n   * @param config the router config\r\n   */\r\n  private static encodePlan(\r\n    planner: RoutePlanner,\r\n    nativeCurrencyValue: BigNumber,\r\n    config: SwapRouterConfig = {}\r\n  ): MethodParameters {\r\n    const { commands, inputs } = planner\r\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\r\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\r\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\r\n    return { calldata, value: nativeCurrencyValue.toHexString() }\r\n  }\r\n}\r\n","import { TradeConfig } from '../Command'\r\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\nexport type CryptopunkData = {\r\n  tokenId: BigNumberish\r\n  recipient: string\r\n  value: BigNumberish\r\n}\r\n\r\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\r\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\r\n\r\n  constructor(orders: CryptopunkData[]) {\r\n    super(Market.Cryptopunks, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const item of this.orders) {\r\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const item of this.orders) {\r\n      buyItems.push({\r\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\r\n        tokenId: item.tokenId,\r\n        tokenType: TokenType.Cryptopunk,\r\n      })\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const item of this.orders) {\r\n      total = total.add(item.value)\r\n    }\r\n    return total\r\n  }\r\n}\r\n","import abi from '../../../abis/Foundation.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\r\nimport { TradeConfig } from '../Command'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\nexport type FoundationData = {\r\n  recipient: string\r\n  tokenAddress: string\r\n  tokenId: BigNumberish\r\n  price: BigNumberish\r\n  referrer: string // address\r\n}\r\n\r\nexport class FoundationTrade extends NFTTrade<FoundationData> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n\r\n  constructor(orders: FoundationData[]) {\r\n    super(Market.Foundation, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const item of this.orders) {\r\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\r\n        item.tokenAddress,\r\n        item.tokenId,\r\n        item.price,\r\n        item.referrer,\r\n      ])\r\n      planner.addCommand(\r\n        CommandType.FOUNDATION,\r\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\r\n        config.allowRevert\r\n      )\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const item of this.orders) {\r\n      buyItems.push({\r\n        tokenAddress: item.tokenAddress,\r\n        tokenId: item.tokenId,\r\n        tokenType: TokenType.ERC721,\r\n      })\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const item of this.orders) {\r\n      total = total.add(item.price)\r\n    }\r\n    return total\r\n  }\r\n}\r\n","import abi from '../../../abis/LooksRareV2.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\r\nimport { TradeConfig } from '../Command'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber } from 'ethers'\r\nimport { ZERO_ADDRESS } from '../../utils/constants'\r\n\r\nexport type MakerOrder = {\r\n  quoteType: number\r\n  globalNonce: string\r\n  subsetNonce: string\r\n  orderNonce: string\r\n  strategyId: number\r\n  collectionType: number\r\n  collection: string\r\n  currency: string\r\n  signer: string\r\n  startTime: number\r\n  endTime: number\r\n  price: string\r\n  itemIds: string[]\r\n  amounts: string[]\r\n  additionalParameters: string\r\n}\r\n\r\nexport type TakerOrder = {\r\n  recipient: string\r\n  additionalParameters: string\r\n}\r\n\r\nexport type MerkleProof = {\r\n  value: string\r\n  position: number\r\n}\r\n\r\nexport type MerkleTree = {\r\n  root: string\r\n  proof: MerkleProof[]\r\n}\r\n\r\nexport type LRV2APIOrder = MakerOrder & {\r\n  id: string\r\n  hash: string\r\n  signature: string\r\n  createdAt: string\r\n  merkleRoot?: string\r\n  merkleProof?: MerkleProof[]\r\n  status: string\r\n}\r\n\r\nexport type LooksRareV2Data = {\r\n  apiOrder: LRV2APIOrder\r\n  taker: string\r\n}\r\n\r\nexport class LooksRareV2Trade extends NFTTrade<LooksRareV2Data> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n  private static ERC721_ORDER = 0\r\n\r\n  constructor(orders: LooksRareV2Data[]) {\r\n    super(Market.LooksRareV2, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    const { takerBids, makerOrders, makerSignatures, totalValue, merkleTrees } = this.refactorAPIData(this.orders)\r\n\r\n    let calldata\r\n    if (this.orders.length == 1) {\r\n      calldata = LooksRareV2Trade.INTERFACE.encodeFunctionData('executeTakerBid', [\r\n        takerBids[0],\r\n        makerOrders[0],\r\n        makerSignatures[0],\r\n        merkleTrees[0],\r\n        ZERO_ADDRESS, // affiliate\r\n      ])\r\n    } else {\r\n      calldata = LooksRareV2Trade.INTERFACE.encodeFunctionData('executeMultipleTakerBids', [\r\n        takerBids,\r\n        makerOrders,\r\n        makerSignatures,\r\n        merkleTrees,\r\n        ZERO_ADDRESS, // affiliate\r\n        false, // isAtomic (we deal with this in allowRevert)\r\n      ])\r\n    }\r\n\r\n    planner.addCommand(CommandType.LOOKS_RARE_V2, [totalValue, calldata], config.allowRevert)\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const item of this.orders) {\r\n      const tokenAddress = item.apiOrder.collection\r\n      const tokenType =\r\n        item.apiOrder.collectionType == LooksRareV2Trade.ERC721_ORDER ? TokenType.ERC721 : TokenType.ERC1155\r\n      for (const tokenId of item.apiOrder.itemIds)\r\n        buyItems.push({\r\n          tokenAddress,\r\n          tokenId,\r\n          tokenType,\r\n        })\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const item of this.orders) {\r\n      total = total.add(item.apiOrder.price)\r\n    }\r\n    return total\r\n  }\r\n\r\n  private refactorAPIData(orders: LooksRareV2Data[]): {\r\n    takerBids: TakerOrder[]\r\n    makerOrders: MakerOrder[]\r\n    makerSignatures: string[]\r\n    totalValue: BigNumber\r\n    merkleTrees: MerkleTree[]\r\n  } {\r\n    let takerBids: TakerOrder[] = []\r\n    let makerOrders: MakerOrder[] = []\r\n    let makerSignatures: string[] = []\r\n    let totalValue: BigNumber = BigNumber.from(0)\r\n    let merkleTrees: MerkleTree[] = []\r\n\r\n    orders.forEach((order) => {\r\n      makerOrders.push({ ...order.apiOrder })\r\n\r\n      makerSignatures.push(order.apiOrder.signature)\r\n\r\n      takerBids.push({\r\n        recipient: order.taker,\r\n        additionalParameters: '0x',\r\n      })\r\n\r\n      totalValue = totalValue.add(BigNumber.from(order.apiOrder.price))\r\n\r\n      merkleTrees.push({\r\n        root: order.apiOrder.merkleRoot ?? '0x0000000000000000000000000000000000000000000000000000000000000000',\r\n        proof: order.apiOrder.merkleProof ?? [],\r\n      })\r\n    })\r\n\r\n    return { takerBids, makerOrders, makerSignatures, totalValue, merkleTrees }\r\n  }\r\n}\r\n","import abi from '../../../abis/NFT20.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { TradeConfig } from '../Command'\r\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\nexport type NFT20Data = {\r\n  tokenAddress: string\r\n  tokenIds: BigNumberish[]\r\n  tokenAmounts: BigNumberish[]\r\n  recipient: string\r\n  fee: BigNumberish\r\n  isV3: boolean\r\n  value: BigNumberish\r\n}\r\n\r\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n\r\n  constructor(orders: NFT20Data[]) {\r\n    super(Market.NFT20, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const order of this.orders) {\r\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\r\n        order.tokenAddress,\r\n        order.tokenIds,\r\n        order.tokenAmounts,\r\n        order.recipient,\r\n        order.fee,\r\n        order.isV3,\r\n      ])\r\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const pool of this.orders) {\r\n      for (const tokenId of pool.tokenIds) {\r\n        buyItems.push({\r\n          tokenAddress: pool.tokenAddress,\r\n          tokenId: tokenId,\r\n          tokenType: TokenType.ERC721,\r\n        })\r\n      }\r\n    }\r\n\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const item of this.orders) {\r\n      total = total.add(item.value)\r\n    }\r\n    return total\r\n  }\r\n}\r\n","import abi from '../../../abis/NFTXZap.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\r\nimport { TradeConfig } from '../Command'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\nexport type NFTXData = {\r\n  recipient: string\r\n  vaultId: BigNumberish\r\n  tokenAddress: string\r\n  tokenIds: BigNumberish[]\r\n  value: BigNumber\r\n  swapCalldata: string\r\n}\r\n\r\nexport class NFTXTrade extends NFTTrade<NFTXData> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n\r\n  constructor(orders: NFTXData[]) {\r\n    super(Market.NFTX, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const order of this.orders) {\r\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\r\n        order.vaultId,\r\n        order.tokenIds.length,\r\n        order.tokenIds,\r\n        order.swapCalldata,\r\n        order.recipient,\r\n      ])\r\n\r\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const order of this.orders) {\r\n      for (const tokenId of order.tokenIds) {\r\n        buyItems.push({\r\n          tokenAddress: order.tokenAddress,\r\n          tokenId: tokenId,\r\n          tokenType: TokenType.ERC721,\r\n        })\r\n      }\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const item of this.orders) {\r\n      total = total.add(item.value)\r\n    }\r\n    return total\r\n  }\r\n}\r\n","import { BigNumber, BigNumberish } from 'ethers'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport abi from '../../../abis/Seaport.json'\r\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\r\nimport { TradeConfig } from '../Command'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { encodeInputTokenOptions, Permit2Permit } from '../../utils/inputTokens'\r\nimport { ETH_ADDRESS } from '../../utils/constants'\r\n\r\nexport type SeaportData = {\r\n  items: Order[]\r\n  recipient: string // address\r\n  protocolAddress: string\r\n  inputTokenProcessing?: InputTokenProcessing[]\r\n}\r\n\r\nexport type InputTokenProcessing = {\r\n  token: string\r\n  permit2Permit?: Permit2Permit\r\n  protocolApproval: boolean\r\n  permit2TransferFrom: boolean\r\n}\r\n\r\nexport type FulfillmentComponent = {\r\n  orderIndex: BigNumberish\r\n  itemIndex: BigNumberish\r\n}\r\n\r\nexport type OfferItem = {\r\n  itemType: BigNumberish // enum\r\n  token: string // address\r\n  identifierOrCriteria: BigNumberish\r\n  startAmount: BigNumberish\r\n  endAmount: BigNumberish\r\n}\r\n\r\nexport type ConsiderationItem = OfferItem & {\r\n  recipient: string\r\n}\r\n\r\nexport type Order = {\r\n  parameters: OrderParameters\r\n  signature: string\r\n}\r\n\r\ntype OrderParameters = {\r\n  offerer: string // address,\r\n  offer: OfferItem[]\r\n  consideration: ConsiderationItem[]\r\n  orderType: BigNumberish // enum\r\n  startTime: BigNumberish\r\n  endTime: BigNumberish\r\n  zoneHash: string // bytes32\r\n  zone: string // address\r\n  salt: BigNumberish\r\n  conduitKey: string // bytes32,\r\n  totalOriginalConsiderationItems: BigNumberish\r\n}\r\n\r\nexport type AdvancedOrder = Order & {\r\n  numerator: BigNumber // uint120\r\n  denominator: BigNumber // uint120\r\n  extraData: string // bytes\r\n}\r\n\r\nexport class SeaportTrade extends NFTTrade<SeaportData> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\r\n\r\n  constructor(orders: SeaportData[]) {\r\n    super(Market.Seaport, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const order of this.orders) {\r\n      let advancedOrders: AdvancedOrder[] = []\r\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\r\n        { orderIndex: index, itemIndex: 0 },\r\n      ])\r\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\r\n\r\n      for (const item of order.items) {\r\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\r\n        advancedOrders.push(advancedOrder)\r\n      }\r\n\r\n      let calldata: string\r\n      if (advancedOrders.length == 1) {\r\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\r\n          advancedOrders[0],\r\n          [],\r\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\r\n          order.recipient,\r\n        ])\r\n      } else {\r\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\r\n          advancedOrders,\r\n          [],\r\n          orderFulfillments,\r\n          considerationFulFillments,\r\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\r\n          order.recipient,\r\n          100, // TODO: look into making this a better number\r\n        ])\r\n      }\r\n\r\n      if (!!order.inputTokenProcessing) {\r\n        for (const inputToken of order.inputTokenProcessing)\r\n          encodeInputTokenOptions(planner, {\r\n            approval: inputToken.protocolApproval\r\n              ? { token: inputToken.token, protocol: order.protocolAddress }\r\n              : undefined,\r\n            permit2Permit: inputToken.permit2Permit,\r\n            permit2TransferFrom: inputToken.permit2TransferFrom\r\n              ? { token: inputToken.token, amount: this.getTotalOrderPrice(order, inputToken.token).toString() }\r\n              : undefined,\r\n          })\r\n      }\r\n\r\n      planner.addCommand(\r\n        this.commandMap(order.protocolAddress),\r\n        [this.getTotalOrderPrice(order, ETH_ADDRESS).toString(), calldata],\r\n        config.allowRevert\r\n      )\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const order of this.orders) {\r\n      for (const item of order.items) {\r\n        for (const offer of item.parameters.offer) {\r\n          buyItems.push({\r\n            tokenAddress: offer.token,\r\n            tokenId: offer.identifierOrCriteria,\r\n            tokenType: TokenType.ERC721,\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getInputTokens(): Set<string> {\r\n    let inputTokens = new Set<string>()\r\n    for (const order of this.orders) {\r\n      for (const item of order.items) {\r\n        for (const consideration of item.parameters.consideration) {\r\n          const token = consideration.token.toLowerCase()\r\n          inputTokens.add(token)\r\n        }\r\n      }\r\n    }\r\n    return inputTokens\r\n  }\r\n\r\n  getTotalOrderPrice(order: SeaportData, token: string = ETH_ADDRESS): BigNumber {\r\n    let totalOrderPrice = BigNumber.from(0)\r\n    for (const item of order.items) {\r\n      totalOrderPrice = totalOrderPrice.add(this.calculateValue(item.parameters.consideration, token))\r\n    }\r\n    return totalOrderPrice\r\n  }\r\n\r\n  getTotalPrice(token: string = ETH_ADDRESS): BigNumber {\r\n    let totalPrice = BigNumber.from(0)\r\n    for (const order of this.orders) {\r\n      for (const item of order.items) {\r\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration, token))\r\n      }\r\n    }\r\n    return totalPrice\r\n  }\r\n\r\n  private commandMap(protocolAddress: string): CommandType {\r\n    switch (protocolAddress.toLowerCase()) {\r\n      case '0x00000000000000adc04c56bf30ac9d3c0aaf14dc': // Seaport v1.5\r\n        return CommandType.SEAPORT_V1_5\r\n      case '0x00000000000001ad428e4906ae43d8f9852d0dd6': // Seaport v1.4\r\n        return CommandType.SEAPORT_V1_4\r\n      default:\r\n        throw new Error('unsupported Seaport address')\r\n    }\r\n  }\r\n\r\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\r\n    let considerationFulfillments: FulfillmentComponent[][] = []\r\n    const considerationRecipients: string[] = []\r\n\r\n    for (const i in protocolDatas) {\r\n      const protocolData = protocolDatas[i]\r\n\r\n      for (const j in protocolData.parameters.consideration) {\r\n        const item = protocolData.parameters.consideration[j]\r\n\r\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\r\n          considerationRecipients.push(item.recipient)\r\n        }\r\n\r\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\r\n\r\n        if (!considerationFulfillments[recipientIndex]) {\r\n          considerationFulfillments.push([\r\n            {\r\n              orderIndex: i,\r\n              itemIndex: j,\r\n            },\r\n          ])\r\n        } else {\r\n          considerationFulfillments[recipientIndex].push({\r\n            orderIndex: i,\r\n            itemIndex: j,\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return considerationFulfillments\r\n  }\r\n\r\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder } {\r\n    const advancedOrder = {\r\n      parameters: data.parameters,\r\n      numerator: BigNumber.from('1'),\r\n      denominator: BigNumber.from('1'),\r\n      signature: data.signature,\r\n      extraData: '0x00',\r\n    }\r\n    return { advancedOrder }\r\n  }\r\n\r\n  private calculateValue(considerations: ConsiderationItem[], token: string): BigNumber {\r\n    return considerations.reduce(\r\n      (amt: BigNumber, consideration: ConsiderationItem) =>\r\n        consideration.token.toLowerCase() == token.toLowerCase() ? amt.add(consideration.startAmount) : amt,\r\n      BigNumber.from(0)\r\n    )\r\n  }\r\n}\r\n","import abi from '../../../abis/Sudoswap.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\r\nimport { TradeConfig } from '../Command'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\ntype PairSwap = {\r\n  swapInfo: {\r\n    pair: string // address\r\n    nftIds: BigNumberish[]\r\n  }\r\n  tokenAddress: string // address\r\n  maxCost: BigNumberish\r\n}\r\n\r\nexport type SudoswapData = {\r\n  swaps: PairSwap[]\r\n  nftRecipient: string\r\n  ethRecipient: string\r\n  deadline: BigNumberish\r\n}\r\n\r\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n\r\n  constructor(orders: SudoswapData[]) {\r\n    super(Market.Sudoswap, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const order of this.orders) {\r\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\r\n        order.swaps.map((swap) => {\r\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\r\n        }),\r\n        order.ethRecipient,\r\n        order.nftRecipient,\r\n        order.deadline,\r\n      ])\r\n      const value = order.swaps.reduce((prevVal, swap) => {\r\n        return prevVal.add(swap.maxCost)\r\n      }, BigNumber.from(0))\r\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const order of this.orders) {\r\n      for (const swap of order.swaps) {\r\n        for (const tokenId of swap.swapInfo.nftIds) {\r\n          buyItems.push({\r\n            tokenAddress: swap.tokenAddress,\r\n            tokenId,\r\n            tokenType: TokenType.ERC721,\r\n          })\r\n        }\r\n      }\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const order of this.orders) {\r\n      for (const swap of order.swaps) {\r\n        total = total.add(swap.maxCost)\r\n      }\r\n    }\r\n    return total\r\n  }\r\n}\r\n","import abi from '../../../abis/X2Y2.json'\r\nimport { Interface } from '@ethersproject/abi'\r\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\r\nimport { TradeConfig } from '../Command'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { BigNumber, BigNumberish } from 'ethers'\r\n\r\ntype X2Y2PartialData = {\r\n  signedInput: string\r\n  recipient: string\r\n  tokenAddress: string\r\n  tokenId: BigNumberish\r\n  price: BigNumberish\r\n}\r\n\r\nexport type X2Y2_721_Data = X2Y2PartialData & {\r\n  tokenType: TokenType.ERC721\r\n}\r\n\r\nexport type X2Y2_1155_Data = X2Y2PartialData & {\r\n  tokenType: TokenType.ERC1155\r\n  tokenAmount: BigNumberish\r\n}\r\n\r\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\r\n\r\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\r\n  public static INTERFACE: Interface = new Interface(abi)\r\n\r\n  constructor(orders: X2Y2Data[]) {\r\n    super(Market.X2Y2, orders)\r\n  }\r\n\r\n  encode(planner: RoutePlanner, config: TradeConfig): void {\r\n    for (const item of this.orders) {\r\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\r\n      const calldata = functionSelector + item.signedInput.slice(2)\r\n\r\n      if (item.tokenType == TokenType.ERC721) {\r\n        planner.addCommand(\r\n          CommandType.X2Y2_721,\r\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\r\n          config.allowRevert\r\n        )\r\n      } else if (item.tokenType == TokenType.ERC1155) {\r\n        planner.addCommand(\r\n          CommandType.X2Y2_1155,\r\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\r\n          config.allowRevert\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  getBuyItems(): BuyItem[] {\r\n    let buyItems: BuyItem[] = []\r\n    for (const item of this.orders) {\r\n      buyItems.push({\r\n        tokenAddress: item.tokenAddress,\r\n        tokenId: item.tokenId,\r\n        tokenType: item.tokenType,\r\n      })\r\n    }\r\n    return buyItems\r\n  }\r\n\r\n  getTotalPrice(): BigNumber {\r\n    let total = BigNumber.from(0)\r\n    for (const item of this.orders) {\r\n      total = total.add(item.price)\r\n    }\r\n    return total\r\n  }\r\n}\r\n","import { MixedRouteSDK, Trade as RouterTrade } from '@uniswap/router-sdk'\r\nimport { Currency, CurrencyAmount, Ether, Token, TradeType } from '@uniswap/sdk-core'\r\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk'\r\nimport { Pool, Route as V3Route, FeeAmount } from '@uniswap/v3-sdk'\r\nimport { BigNumber } from 'ethers'\r\nimport { ETH_ADDRESS, E_ETH_ADDRESS } from './constants'\r\n\r\nexport type TokenInRoute = {\r\n  address: string\r\n  chainId: number\r\n  symbol: string\r\n  decimals: string\r\n  name?: string\r\n  buyFeeBps?: string\r\n  sellFeeBps?: string\r\n}\r\n\r\nexport enum PoolType {\r\n  V2Pool = 'v2-pool',\r\n  V3Pool = 'v3-pool',\r\n}\r\n\r\nexport type V2Reserve = {\r\n  token: TokenInRoute\r\n  quotient: string\r\n}\r\n\r\nexport type V2PoolInRoute = {\r\n  type: PoolType.V2Pool\r\n  address?: string\r\n  tokenIn: TokenInRoute\r\n  tokenOut: TokenInRoute\r\n  reserve0: V2Reserve\r\n  reserve1: V2Reserve\r\n  amountIn?: string\r\n  amountOut?: string\r\n}\r\n\r\nexport type V3PoolInRoute = {\r\n  type: PoolType.V3Pool\r\n  address?: string\r\n  tokenIn: TokenInRoute\r\n  tokenOut: TokenInRoute\r\n  sqrtRatioX96: string\r\n  liquidity: string\r\n  tickCurrent: string\r\n  fee: string\r\n  amountIn?: string\r\n  amountOut?: string\r\n}\r\n\r\nexport type PartialClassicQuote = {\r\n  // We need tokenIn/Out to support native currency\r\n  tokenIn: string\r\n  tokenOut: string\r\n  tradeType: TradeType\r\n  route: Array<(V3PoolInRoute | V2PoolInRoute)[]>\r\n}\r\n\r\ninterface RouteResult {\r\n  routev3: V3Route<Currency, Currency> | null\r\n  routev2: V2Route<Currency, Currency> | null\r\n  mixedRoute: MixedRouteSDK<Currency, Currency> | null\r\n  inputAmount: CurrencyAmount<Currency>\r\n  outputAmount: CurrencyAmount<Currency>\r\n}\r\n\r\nexport const isNativeCurrency = (address: string) =>\r\n  address.toLowerCase() === ETH_ADDRESS.toLowerCase() || address.toLowerCase() === E_ETH_ADDRESS.toLowerCase()\r\n\r\n// Helper class to convert routing-specific quote entities to RouterTrade entities\r\n// the returned RouterTrade can then be used to build the UniswapTrade entity in this package\r\nexport class RouterTradeAdapter {\r\n  // Generate a RouterTrade using fields from a classic quote response\r\n  static fromClassicQuote(quote: PartialClassicQuote) {\r\n    const { route, tokenIn, tokenOut } = quote\r\n\r\n    if (!route) throw new Error('Expected route to be present')\r\n    if (!route.length) throw new Error('Expected there to be at least one route')\r\n    if (route.some((r) => !r.length)) throw new Error('Expected all routes to have at least one pool')\r\n    const firstRoute = route[0]\r\n\r\n    const tokenInData = firstRoute[0].tokenIn\r\n    const tokenOutData = firstRoute[firstRoute.length - 1].tokenOut\r\n\r\n    if (!tokenInData || !tokenOutData) throw new Error('Expected both tokenIn and tokenOut to be present')\r\n    if (tokenInData.chainId !== tokenOutData.chainId)\r\n      throw new Error('Expected tokenIn and tokenOut to be have same chainId')\r\n\r\n    const parsedCurrencyIn = RouterTradeAdapter.toCurrency(isNativeCurrency(tokenIn), tokenInData)\r\n    const parsedCurrencyOut = RouterTradeAdapter.toCurrency(isNativeCurrency(tokenOut), tokenOutData)\r\n\r\n    const typedRoutes: RouteResult[] = route.map((subRoute) => {\r\n      const rawAmountIn = subRoute[0].amountIn\r\n      const rawAmountOut = subRoute[subRoute.length - 1].amountOut\r\n\r\n      if (!rawAmountIn || !rawAmountOut) {\r\n        throw new Error('Expected both raw amountIn and raw amountOut to be present')\r\n      }\r\n\r\n      const inputAmount = CurrencyAmount.fromRawAmount(parsedCurrencyIn, rawAmountIn)\r\n      const outputAmount = CurrencyAmount.fromRawAmount(parsedCurrencyOut, rawAmountOut)\r\n\r\n      const isOnlyV2 = RouterTradeAdapter.isVersionedRoute<V2PoolInRoute>(PoolType.V2Pool, subRoute)\r\n      const isOnlyV3 = RouterTradeAdapter.isVersionedRoute<V3PoolInRoute>(PoolType.V3Pool, subRoute)\r\n\r\n      return {\r\n        routev3: isOnlyV3\r\n          ? new V3Route(\r\n              (subRoute as V3PoolInRoute[]).map(RouterTradeAdapter.toPool),\r\n              parsedCurrencyIn,\r\n              parsedCurrencyOut\r\n            )\r\n          : null,\r\n        routev2: isOnlyV2\r\n          ? new V2Route(\r\n              (subRoute as V2PoolInRoute[]).map(RouterTradeAdapter.toPair),\r\n              parsedCurrencyIn,\r\n              parsedCurrencyOut\r\n            )\r\n          : null,\r\n        mixedRoute:\r\n          !isOnlyV3 && !isOnlyV2\r\n            ? new MixedRouteSDK(subRoute.map(RouterTradeAdapter.toPoolOrPair), parsedCurrencyIn, parsedCurrencyOut)\r\n            : null,\r\n        inputAmount,\r\n        outputAmount,\r\n      }\r\n    })\r\n\r\n    return new RouterTrade({\r\n      v2Routes: typedRoutes\r\n        .filter((route) => route.routev2)\r\n        .map((route) => ({\r\n          routev2: route.routev2 as V2Route<Currency, Currency>,\r\n          inputAmount: route.inputAmount,\r\n          outputAmount: route.outputAmount,\r\n        })),\r\n      v3Routes: typedRoutes\r\n        .filter((route) => route.routev3)\r\n        .map((route) => ({\r\n          routev3: route.routev3 as V3Route<Currency, Currency>,\r\n          inputAmount: route.inputAmount,\r\n          outputAmount: route.outputAmount,\r\n        })),\r\n      mixedRoutes: typedRoutes\r\n        .filter((route) => route.mixedRoute)\r\n        .map((route) => ({\r\n          mixedRoute: route.mixedRoute as MixedRouteSDK<Currency, Currency>,\r\n          inputAmount: route.inputAmount,\r\n          outputAmount: route.outputAmount,\r\n        })),\r\n      tradeType: quote.tradeType,\r\n    })\r\n  }\r\n\r\n  private static toCurrency(isNative: boolean, token: TokenInRoute): Currency {\r\n    if (isNative) {\r\n      return Ether.onChain(token.chainId)\r\n    }\r\n    return this.toToken(token)\r\n  }\r\n\r\n  private static toPoolOrPair = (pool: V3PoolInRoute | V2PoolInRoute): Pool | Pair => {\r\n    return pool.type === PoolType.V3Pool ? RouterTradeAdapter.toPool(pool) : RouterTradeAdapter.toPair(pool)\r\n  }\r\n\r\n  private static toToken(token: TokenInRoute): Token {\r\n    const { chainId, address, decimals, symbol, buyFeeBps, sellFeeBps } = token\r\n    return new Token(\r\n      chainId,\r\n      address,\r\n      parseInt(decimals.toString()),\r\n      symbol,\r\n      /* name */ undefined,\r\n      false,\r\n      buyFeeBps ? BigNumber.from(buyFeeBps) : undefined,\r\n      sellFeeBps ? BigNumber.from(sellFeeBps) : undefined\r\n    )\r\n  }\r\n\r\n  private static toPool({ fee, sqrtRatioX96, liquidity, tickCurrent, tokenIn, tokenOut }: V3PoolInRoute): Pool {\r\n    return new Pool(\r\n      RouterTradeAdapter.toToken(tokenIn),\r\n      RouterTradeAdapter.toToken(tokenOut),\r\n      parseInt(fee) as FeeAmount,\r\n      sqrtRatioX96,\r\n      liquidity,\r\n      parseInt(tickCurrent)\r\n    )\r\n  }\r\n\r\n  private static toPair = ({ reserve0, reserve1 }: V2PoolInRoute): Pair => {\r\n    return new Pair(\r\n      CurrencyAmount.fromRawAmount(RouterTradeAdapter.toToken(reserve0.token), reserve0.quotient),\r\n      CurrencyAmount.fromRawAmount(RouterTradeAdapter.toToken(reserve1.token), reserve1.quotient)\r\n    )\r\n  }\r\n\r\n  private static isVersionedRoute<T extends V2PoolInRoute | V3PoolInRoute>(\r\n    type: PoolType,\r\n    route: (V3PoolInRoute | V2PoolInRoute)[]\r\n  ): route is T[] {\r\n    return route.every((pool) => pool.type === type)\r\n  }\r\n}\r\n","import invariant from 'tiny-invariant'\r\nimport { BigNumberish } from 'ethers'\r\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\r\nimport { encodeInputTokenOptions, Permit2Permit } from '../../utils/inputTokens'\r\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\r\nimport { ROUTER_AS_RECIPIENT, WETH_ADDRESS } from '../../utils/constants'\r\n\r\nexport class UnwrapWETH implements Command {\r\n  readonly tradeType: RouterTradeType = RouterTradeType.UnwrapWETH\r\n  readonly permit2Data: Permit2Permit\r\n  readonly wethAddress: string\r\n  readonly amount: BigNumberish\r\n\r\n  constructor(amount: BigNumberish, chainId: number, permit2?: Permit2Permit) {\r\n    this.wethAddress = WETH_ADDRESS(chainId)\r\n    this.amount = amount\r\n\r\n    if (!!permit2) {\r\n      invariant(\r\n        permit2.details.token.toLowerCase() === this.wethAddress.toLowerCase(),\r\n        `must be permitting WETH address: ${this.wethAddress}`\r\n      )\r\n      invariant(permit2.details.amount >= amount, `Did not permit enough WETH for unwrapWETH transaction`)\r\n      this.permit2Data = permit2\r\n    }\r\n  }\r\n\r\n  encode(planner: RoutePlanner, _: TradeConfig): void {\r\n    encodeInputTokenOptions(planner, {\r\n      permit2Permit: this.permit2Data,\r\n      permit2TransferFrom: {\r\n        token: this.wethAddress,\r\n        amount: this.amount.toString(),\r\n      },\r\n    })\r\n    planner.addCommand(CommandType.UNWRAP_WETH, [ROUTER_AS_RECIPIENT, this.amount])\r\n  }\r\n}\r\n"],"names":["RouterTradeType","Market","TokenType","CommandType","NFTTrade","market","orders","this","length","invariant","REVERTIBLE_COMMANDS","Set","SEAPORT_V1_5","SEAPORT_V1_4","NFTX","LOOKS_RARE_V2","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","EXECUTE_SUB_PLAN","CRYPTOPUNKS","ELEMENT_MARKET","ABI_DEFINITION","PERMIT2_PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","PERMIT2_TRANSFER_FROM_STRUCT","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","SWEEP_ERC721","SWEEP_ERC1155","TRANSFER","PAY_PORTION","BALANCE_CHECK_ERC20","OWNER_CHECK_721","OWNER_CHECK_1155","APPROVE_ERC20","RoutePlanner","commands","inputs","_proto","addSubPlan","subplan","addCommand","type","parameters","allowRevert","command","encodedInput","defaultAbiCoder","encode","createCommand","push","has","Error","concat","toString","padStart","CHAIN_CONFIGS","router","weth","creationBlock","WETH_ADDRESS","chainId","CONTRACT_BALANCE","BigNumber","from","pow","ETH_ADDRESS","ZERO_ADDRESS","SENDER_AS_RECIPIENT","ROUTER_AS_RECIPIENT","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","UniswapTrade","trade","options","fee","flatFee","payerIsUser","inputRequiresWrap","useRouterBalance","planner","_config","maximumAmountIn","slippageTolerance","quotient","recipient","swapOptions","outputIsNative","outputAmount","currency","isNative","routerMustCustody","tradeType","TradeType","EXACT_INPUT","routes","swaps","swap","route","protocol","Protocol","V2","addV2Swap","V3","addV3Swap","MIXED","addMixedSwap","minimumAmountOut","feeBips","toHex","multiply","wrapped","address","EXACT_OUTPUT","sub","mul","div","feeAmount","amount","lt","priceImpact","greaterThan","safeMode","key","get","inputAmount","V2Trade","path","map","pool","V3Trade","createUncheckedTrade","encodeRouteToPath","tradeRecipient","pools","Pool","Pair","outputToken","MixedRouteTrade","amountIn","amountOut","sections","partitionMixedRouteByProtocol","isLastSectionInRoute","i","inputToken","input","section","getOutputOfPools","newRouteOriginal","MixedRouteSDK","token0","equals","token1","newRoute","MixedRoute","every","mixedRouteIsAllV3","encodeMixedRouteToPath","liquidityToken","encodePermit","permit2","signature","ethers","utils","arrayify","joinSignature","splitSignature","encodeInputTokenOptions","approval","permit2Permit","token","details","permit2TransferFrom","mapApprovalProtocol","protocolAddress","toLowerCase","SwapRouter","swapCallParameters","trades","config","Array","isArray","nftTrades","filter","_","hasOwnProperty","currentNativeValueInRouter","transactionValue","nftInputTokens","nftTrade","tradePrice","getTotalPrice","Seaport","getInputTokens","forEach","add","uniswapTrade","inputIsNative","inputTokenPermit","UnwrapWETH","encodePlan","swapNFTCallParameters","totalPrice","swapERC20CallParameters","inputCurrency","nativeCurrencyValue","deadline","deadlineOrPreviousBlockhash","undefined","calldata","INTERFACE","encodeFunctionData","value","toHexString","Interface","abi","CryptopunkTrade","_NFTTrade","Cryptopunks","_inheritsLoose","item","tokenId","getBuyItems","buyItems","tokenAddress","CRYPTOPUNK_ADDRESS","tokenType","Cryptopunk","total","FoundationTrade","Foundation","price","referrer","ERC721","LooksRareV2Trade","LooksRareV2","refactorAPIData","takerBids","makerOrders","makerSignatures","totalValue","merkleTrees","apiOrder","collection","collectionType","ERC721_ORDER","ERC1155","itemIds","order","taker","additionalParameters","root","merkleRoot","proof","merkleProof","NFT20Trade","tokenIds","tokenAmounts","isV3","NFTXTrade","vaultId","swapCalldata","SeaportTrade","advancedOrders","orderFulfillments","items","index","orderIndex","itemIndex","considerationFulFillments","getConsiderationFulfillments","getAdvancedOrderParams","advancedOrder","OPENSEA_CONDUIT_KEY","inputTokenProcessing","protocolApproval","getTotalOrderPrice","commandMap","offer","identifierOrCriteria","inputTokens","consideration","totalOrderPrice","calculateValue","protocolDatas","considerationFulfillments","considerationRecipients","protocolData","j","findIndex","x","recipientIndex","_loop","data","numerator","denominator","extraData","considerations","reduce","amt","startAmount","SudoswapTrade","Sudoswap","swapInfo","maxCost","ethRecipient","nftRecipient","prevVal","nftIds","X2Y2Trade","X2Y2","getSighash","getFunction","signedInput","slice","tokenAmount","PoolType","wethAddress","permit2Data","isNativeCurrency","RouterTradeAdapter","fromClassicQuote","quote","tokenIn","tokenOut","some","r","firstRoute","tokenInData","tokenOutData","parsedCurrencyIn","toCurrency","parsedCurrencyOut","typedRoutes","subRoute","rawAmountIn","rawAmountOut","CurrencyAmount","fromRawAmount","isOnlyV2","isVersionedRoute","V2Pool","isOnlyV3","V3Pool","routev3","V3Route","toPool","routev2","V2Route","toPair","mixedRoute","toPoolOrPair","RouterTrade","v2Routes","v3Routes","mixedRoutes","Ether","onChain","toToken","symbol","buyFeeBps","sellFeeBps","Token","parseInt","decimals","sqrtRatioX96","liquidity","tickCurrent","reserve0","reserve1"],"mappings":"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"}